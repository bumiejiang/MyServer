// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Command.proto

#ifndef PROTOBUF_Command_2eproto__INCLUDED
#define PROTOBUF_Command_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Command_2eproto {
	// Internal implementation detail -- do not use these members.
	struct TableStruct {
		static const ::google::protobuf::internal::ParseTableField entries[];
		static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
		static const ::google::protobuf::internal::ParseTable schema[4];
		static const ::google::protobuf::internal::FieldMetadata field_metadata[];
		static const ::google::protobuf::internal::SerializationTable serialization_table[];
		static const ::google::protobuf::uint32 offsets[];
	};
	void AddDescriptors();
	void InitDefaultsCommandImpl();
	void InitDefaultsCommand();
	void InitDefaultsCommandParamsImpl();
	void InitDefaultsCommandParams();
	void InitDefaultsLoginInfoImpl();
	void InitDefaultsLoginInfo();
	void InitDefaultsGameOperationImpl();
	void InitDefaultsGameOperation();
	inline void InitDefaults() {
		InitDefaultsCommand();
		InitDefaultsCommandParams();
		InitDefaultsLoginInfo();
		InitDefaultsGameOperation();
	}
}  // namespace protobuf_Command_2eproto
namespace GameMsg {
	class Command;
	class CommandDefaultTypeInternal;
	extern CommandDefaultTypeInternal _Command_default_instance_;
	class CommandParams;
	class CommandParamsDefaultTypeInternal;
	extern CommandParamsDefaultTypeInternal _CommandParams_default_instance_;
	class GameOperation;
	class GameOperationDefaultTypeInternal;
	extern GameOperationDefaultTypeInternal _GameOperation_default_instance_;
	class LoginInfo;
	class LoginInfoDefaultTypeInternal;
	extern LoginInfoDefaultTypeInternal _LoginInfo_default_instance_;
}  // namespace GameMsg
namespace GameMsg {

	// ===================================================================

	class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameMsg.Command) */ {
	public:
		Command();
		virtual ~Command();

		Command(const Command& from);

		inline Command& operator=(const Command& from) {
			CopyFrom(from);
			return *this;
		}
#if LANG_CXX11
		Command(Command&& from) noexcept
			: Command() {
			*this = ::std::move(from);
		}

		inline Command& operator=(Command&& from) noexcept {
			if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
				if (this != &from) InternalSwap(&from);
			}
			else {
				CopyFrom(from);
			}
			return *this;
		}
#endif
		static const ::google::protobuf::Descriptor* descriptor();
		static const Command& default_instance();

		static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
		static inline const Command* internal_default_instance() {
			return reinterpret_cast<const Command*>(
				&_Command_default_instance_);
		}
		static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
			0;

		void Swap(Command* other);
		friend void swap(Command& a, Command& b) {
			a.Swap(&b);
		}

		// implements Message ----------------------------------------------

		inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

		Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
		void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void CopyFrom(const Command& from);
		void MergeFrom(const Command& from);
		void Clear() PROTOBUF_FINAL;
		bool IsInitialized() const PROTOBUF_FINAL;

		size_t ByteSizeLong() const PROTOBUF_FINAL;
		bool MergePartialFromCodedStream(
			::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
		void SerializeWithCachedSizes(
			::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
		::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
			bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
		int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
	private:
		void SharedCtor();
		void SharedDtor();
		void SetCachedSize(int size) const PROTOBUF_FINAL;
		void InternalSwap(Command* other);
	private:
		inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
			return NULL;
		}
		inline void* MaybeArenaPtr() const {
			return NULL;
		}
	public:

		::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		// .GameMsg.CommandParams commandParams = 2;
		bool has_commandparams() const;
		void clear_commandparams();
		static const int kCommandParamsFieldNumber = 2;
		const ::GameMsg::CommandParams& commandparams() const;
		::GameMsg::CommandParams* release_commandparams();
		::GameMsg::CommandParams* mutable_commandparams();
		void set_allocated_commandparams(::GameMsg::CommandParams* commandparams);

		// int32 commandID = 1;
		void clear_commandid();
		static const int kCommandIDFieldNumber = 1;
		::google::protobuf::int32 commandid() const;
		void set_commandid(::google::protobuf::int32 value);

		// @@protoc_insertion_point(class_scope:GameMsg.Command)
	private:

		::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
		::GameMsg::CommandParams* commandparams_;
		::google::protobuf::int32 commandid_;
		mutable int _cached_size_;
		friend struct ::protobuf_Command_2eproto::TableStruct;
		friend void ::protobuf_Command_2eproto::InitDefaultsCommandImpl();
	};
	// -------------------------------------------------------------------

	class CommandParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameMsg.CommandParams) */ {
	public:
		CommandParams();
		virtual ~CommandParams();

		CommandParams(const CommandParams& from);

		inline CommandParams& operator=(const CommandParams& from) {
			CopyFrom(from);
			return *this;
		}
#if LANG_CXX11
		CommandParams(CommandParams&& from) noexcept
			: CommandParams() {
			*this = ::std::move(from);
		}

		inline CommandParams& operator=(CommandParams&& from) noexcept {
			if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
				if (this != &from) InternalSwap(&from);
			}
			else {
				CopyFrom(from);
			}
			return *this;
		}
#endif
		static const ::google::protobuf::Descriptor* descriptor();
		static const CommandParams& default_instance();

		static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
		static inline const CommandParams* internal_default_instance() {
			return reinterpret_cast<const CommandParams*>(
				&_CommandParams_default_instance_);
		}
		static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
			1;

		void Swap(CommandParams* other);
		friend void swap(CommandParams& a, CommandParams& b) {
			a.Swap(&b);
		}

		// implements Message ----------------------------------------------

		inline CommandParams* New() const PROTOBUF_FINAL { return New(NULL); }

		CommandParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
		void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void CopyFrom(const CommandParams& from);
		void MergeFrom(const CommandParams& from);
		void Clear() PROTOBUF_FINAL;
		bool IsInitialized() const PROTOBUF_FINAL;

		size_t ByteSizeLong() const PROTOBUF_FINAL;
		bool MergePartialFromCodedStream(
			::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
		void SerializeWithCachedSizes(
			::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
		::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
			bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
		int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
	private:
		void SharedCtor();
		void SharedDtor();
		void SetCachedSize(int size) const PROTOBUF_FINAL;
		void InternalSwap(CommandParams* other);
	private:
		inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
			return NULL;
		}
		inline void* MaybeArenaPtr() const {
			return NULL;
		}
	public:

		::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		// .GameMsg.LoginInfo loginInfo = 2;
		bool has_logininfo() const;
		void clear_logininfo();
		static const int kLoginInfoFieldNumber = 2;
		const ::GameMsg::LoginInfo& logininfo() const;
		::GameMsg::LoginInfo* release_logininfo();
		::GameMsg::LoginInfo* mutable_logininfo();
		void set_allocated_logininfo(::GameMsg::LoginInfo* logininfo);

		// .GameMsg.GameOperation gameOperation = 3;
		bool has_gameoperation() const;
		void clear_gameoperation();
		static const int kGameOperationFieldNumber = 3;
		const ::GameMsg::GameOperation& gameoperation() const;
		::GameMsg::GameOperation* release_gameoperation();
		::GameMsg::GameOperation* mutable_gameoperation();
		void set_allocated_gameoperation(::GameMsg::GameOperation* gameoperation);

		// int32 playerID = 1;
		void clear_playerid();
		static const int kPlayerIDFieldNumber = 1;
		::google::protobuf::int32 playerid() const;
		void set_playerid(::google::protobuf::int32 value);

		// @@protoc_insertion_point(class_scope:GameMsg.CommandParams)
	private:

		::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
		::GameMsg::LoginInfo* logininfo_;
		::GameMsg::GameOperation* gameoperation_;
		::google::protobuf::int32 playerid_;
		mutable int _cached_size_;
		friend struct ::protobuf_Command_2eproto::TableStruct;
		friend void ::protobuf_Command_2eproto::InitDefaultsCommandParamsImpl();
	};
	// -------------------------------------------------------------------

	class LoginInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameMsg.LoginInfo) */ {
	public:
		LoginInfo();
		virtual ~LoginInfo();

		LoginInfo(const LoginInfo& from);

		inline LoginInfo& operator=(const LoginInfo& from) {
			CopyFrom(from);
			return *this;
		}
#if LANG_CXX11
		LoginInfo(LoginInfo&& from) noexcept
			: LoginInfo() {
			*this = ::std::move(from);
		}

		inline LoginInfo& operator=(LoginInfo&& from) noexcept {
			if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
				if (this != &from) InternalSwap(&from);
			}
			else {
				CopyFrom(from);
			}
			return *this;
		}
#endif
		static const ::google::protobuf::Descriptor* descriptor();
		static const LoginInfo& default_instance();

		static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
		static inline const LoginInfo* internal_default_instance() {
			return reinterpret_cast<const LoginInfo*>(
				&_LoginInfo_default_instance_);
		}
		static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
			2;

		void Swap(LoginInfo* other);
		friend void swap(LoginInfo& a, LoginInfo& b) {
			a.Swap(&b);
		}

		// implements Message ----------------------------------------------

		inline LoginInfo* New() const PROTOBUF_FINAL { return New(NULL); }

		LoginInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
		void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void CopyFrom(const LoginInfo& from);
		void MergeFrom(const LoginInfo& from);
		void Clear() PROTOBUF_FINAL;
		bool IsInitialized() const PROTOBUF_FINAL;

		size_t ByteSizeLong() const PROTOBUF_FINAL;
		bool MergePartialFromCodedStream(
			::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
		void SerializeWithCachedSizes(
			::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
		::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
			bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
		int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
	private:
		void SharedCtor();
		void SharedDtor();
		void SetCachedSize(int size) const PROTOBUF_FINAL;
		void InternalSwap(LoginInfo* other);
	private:
		inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
			return NULL;
		}
		inline void* MaybeArenaPtr() const {
			return NULL;
		}
	public:

		::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		// string username = 1;
		void clear_username();
		static const int kUsernameFieldNumber = 1;
		const ::std::string& username() const;
		void set_username(const ::std::string& value);
#if LANG_CXX11
		void set_username(::std::string&& value);
#endif
		void set_username(const char* value);
		void set_username(const char* value, size_t size);
		::std::string* mutable_username();
		::std::string* release_username();
		void set_allocated_username(::std::string* username);

		// string password = 2;
		void clear_password();
		static const int kPasswordFieldNumber = 2;
		const ::std::string& password() const;
		void set_password(const ::std::string& value);
#if LANG_CXX11
		void set_password(::std::string&& value);
#endif
		void set_password(const char* value);
		void set_password(const char* value, size_t size);
		::std::string* mutable_password();
		::std::string* release_password();
		void set_allocated_password(::std::string* password);

		// @@protoc_insertion_point(class_scope:GameMsg.LoginInfo)
	private:

		::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
		::google::protobuf::internal::ArenaStringPtr username_;
		::google::protobuf::internal::ArenaStringPtr password_;
		mutable int _cached_size_;
		friend struct ::protobuf_Command_2eproto::TableStruct;
		friend void ::protobuf_Command_2eproto::InitDefaultsLoginInfoImpl();
	};
	// -------------------------------------------------------------------

	class GameOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameMsg.GameOperation) */ {
	public:
		GameOperation();
		virtual ~GameOperation();

		GameOperation(const GameOperation& from);

		inline GameOperation& operator=(const GameOperation& from) {
			CopyFrom(from);
			return *this;
		}
#if LANG_CXX11
		GameOperation(GameOperation&& from) noexcept
			: GameOperation() {
			*this = ::std::move(from);
		}

		inline GameOperation& operator=(GameOperation&& from) noexcept {
			if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
				if (this != &from) InternalSwap(&from);
			}
			else {
				CopyFrom(from);
			}
			return *this;
		}
#endif
		static const ::google::protobuf::Descriptor* descriptor();
		static const GameOperation& default_instance();

		static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
		static inline const GameOperation* internal_default_instance() {
			return reinterpret_cast<const GameOperation*>(
				&_GameOperation_default_instance_);
		}
		static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
			3;

		void Swap(GameOperation* other);
		friend void swap(GameOperation& a, GameOperation& b) {
			a.Swap(&b);
		}

		// implements Message ----------------------------------------------

		inline GameOperation* New() const PROTOBUF_FINAL { return New(NULL); }

		GameOperation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
		void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
		void CopyFrom(const GameOperation& from);
		void MergeFrom(const GameOperation& from);
		void Clear() PROTOBUF_FINAL;
		bool IsInitialized() const PROTOBUF_FINAL;

		size_t ByteSizeLong() const PROTOBUF_FINAL;
		bool MergePartialFromCodedStream(
			::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
		void SerializeWithCachedSizes(
			::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
		::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
			bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
		int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
	private:
		void SharedCtor();
		void SharedDtor();
		void SetCachedSize(int size) const PROTOBUF_FINAL;
		void InternalSwap(GameOperation* other);
	private:
		inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
			return NULL;
		}
		inline void* MaybeArenaPtr() const {
			return NULL;
		}
	public:

		::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		// bool moveForward = 1;
		void clear_moveforward();
		static const int kMoveForwardFieldNumber = 1;
		bool moveforward() const;
		void set_moveforward(bool value);

		// bool moveBack = 2;
		void clear_moveback();
		static const int kMoveBackFieldNumber = 2;
		bool moveback() const;
		void set_moveback(bool value);

		// bool moveLeft = 3;
		void clear_moveleft();
		static const int kMoveLeftFieldNumber = 3;
		bool moveleft() const;
		void set_moveleft(bool value);

		// bool moveRight = 4;
		void clear_moveright();
		static const int kMoveRightFieldNumber = 4;
		bool moveright() const;
		void set_moveright(bool value);

		// int32 rotation = 5;
		void clear_rotation();
		static const int kRotationFieldNumber = 5;
		::google::protobuf::int32 rotation() const;
		void set_rotation(::google::protobuf::int32 value);

		// @@protoc_insertion_point(class_scope:GameMsg.GameOperation)
	private:

		::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
		bool moveforward_;
		bool moveback_;
		bool moveleft_;
		bool moveright_;
		::google::protobuf::int32 rotation_;
		mutable int _cached_size_;
		friend struct ::protobuf_Command_2eproto::TableStruct;
		friend void ::protobuf_Command_2eproto::InitDefaultsGameOperationImpl();
	};
	// ===================================================================


	// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Command

// int32 commandID = 1;
	inline void Command::clear_commandid() {
		commandid_ = 0;
	}
	inline ::google::protobuf::int32 Command::commandid() const {
		// @@protoc_insertion_point(field_get:GameMsg.Command.commandID)
		return commandid_;
	}
	inline void Command::set_commandid(::google::protobuf::int32 value) {

		commandid_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.Command.commandID)
	}

	// .GameMsg.CommandParams commandParams = 2;
	inline bool Command::has_commandparams() const {
		return this != internal_default_instance() && commandparams_ != NULL;
	}
	inline void Command::clear_commandparams() {
		if (GetArenaNoVirtual() == NULL && commandparams_ != NULL) {
			delete commandparams_;
		}
		commandparams_ = NULL;
	}
	inline const ::GameMsg::CommandParams& Command::commandparams() const {
		const ::GameMsg::CommandParams* p = commandparams_;
		// @@protoc_insertion_point(field_get:GameMsg.Command.commandParams)
		return p != NULL ? *p : *reinterpret_cast<const ::GameMsg::CommandParams*>(
			&::GameMsg::_CommandParams_default_instance_);
	}
	inline ::GameMsg::CommandParams* Command::release_commandparams() {
		// @@protoc_insertion_point(field_release:GameMsg.Command.commandParams)

		::GameMsg::CommandParams* temp = commandparams_;
		commandparams_ = NULL;
		return temp;
	}
	inline ::GameMsg::CommandParams* Command::mutable_commandparams() {

		if (commandparams_ == NULL) {
			commandparams_ = new ::GameMsg::CommandParams;
		}
		// @@protoc_insertion_point(field_mutable:GameMsg.Command.commandParams)
		return commandparams_;
	}
	inline void Command::set_allocated_commandparams(::GameMsg::CommandParams* commandparams) {
		::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
		if (message_arena == NULL) {
			delete commandparams_;
		}
		if (commandparams) {
			::google::protobuf::Arena* submessage_arena = NULL;
			if (message_arena != submessage_arena) {
				commandparams = ::google::protobuf::internal::GetOwnedMessage(
					message_arena, commandparams, submessage_arena);
			}

		}
		else {

		}
		commandparams_ = commandparams;
		// @@protoc_insertion_point(field_set_allocated:GameMsg.Command.commandParams)
	}

	// -------------------------------------------------------------------

	// CommandParams

	// int32 playerID = 1;
	inline void CommandParams::clear_playerid() {
		playerid_ = 0;
	}
	inline ::google::protobuf::int32 CommandParams::playerid() const {
		// @@protoc_insertion_point(field_get:GameMsg.CommandParams.playerID)
		return playerid_;
	}
	inline void CommandParams::set_playerid(::google::protobuf::int32 value) {

		playerid_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.CommandParams.playerID)
	}

	// .GameMsg.LoginInfo loginInfo = 2;
	inline bool CommandParams::has_logininfo() const {
		return this != internal_default_instance() && logininfo_ != NULL;
	}
	inline void CommandParams::clear_logininfo() {
		if (GetArenaNoVirtual() == NULL && logininfo_ != NULL) {
			delete logininfo_;
		}
		logininfo_ = NULL;
	}
	inline const ::GameMsg::LoginInfo& CommandParams::logininfo() const {
		const ::GameMsg::LoginInfo* p = logininfo_;
		// @@protoc_insertion_point(field_get:GameMsg.CommandParams.loginInfo)
		return p != NULL ? *p : *reinterpret_cast<const ::GameMsg::LoginInfo*>(
			&::GameMsg::_LoginInfo_default_instance_);
	}
	inline ::GameMsg::LoginInfo* CommandParams::release_logininfo() {
		// @@protoc_insertion_point(field_release:GameMsg.CommandParams.loginInfo)

		::GameMsg::LoginInfo* temp = logininfo_;
		logininfo_ = NULL;
		return temp;
	}
	inline ::GameMsg::LoginInfo* CommandParams::mutable_logininfo() {

		if (logininfo_ == NULL) {
			logininfo_ = new ::GameMsg::LoginInfo;
		}
		// @@protoc_insertion_point(field_mutable:GameMsg.CommandParams.loginInfo)
		return logininfo_;
	}
	inline void CommandParams::set_allocated_logininfo(::GameMsg::LoginInfo* logininfo) {
		::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
		if (message_arena == NULL) {
			delete logininfo_;
		}
		if (logininfo) {
			::google::protobuf::Arena* submessage_arena = NULL;
			if (message_arena != submessage_arena) {
				logininfo = ::google::protobuf::internal::GetOwnedMessage(
					message_arena, logininfo, submessage_arena);
			}

		}
		else {

		}
		logininfo_ = logininfo;
		// @@protoc_insertion_point(field_set_allocated:GameMsg.CommandParams.loginInfo)
	}

	// .GameMsg.GameOperation gameOperation = 3;
	inline bool CommandParams::has_gameoperation() const {
		return this != internal_default_instance() && gameoperation_ != NULL;
	}
	inline void CommandParams::clear_gameoperation() {
		if (GetArenaNoVirtual() == NULL && gameoperation_ != NULL) {
			delete gameoperation_;
		}
		gameoperation_ = NULL;
	}
	inline const ::GameMsg::GameOperation& CommandParams::gameoperation() const {
		const ::GameMsg::GameOperation* p = gameoperation_;
		// @@protoc_insertion_point(field_get:GameMsg.CommandParams.gameOperation)
		return p != NULL ? *p : *reinterpret_cast<const ::GameMsg::GameOperation*>(
			&::GameMsg::_GameOperation_default_instance_);
	}
	inline ::GameMsg::GameOperation* CommandParams::release_gameoperation() {
		// @@protoc_insertion_point(field_release:GameMsg.CommandParams.gameOperation)

		::GameMsg::GameOperation* temp = gameoperation_;
		gameoperation_ = NULL;
		return temp;
	}
	inline ::GameMsg::GameOperation* CommandParams::mutable_gameoperation() {

		if (gameoperation_ == NULL) {
			gameoperation_ = new ::GameMsg::GameOperation;
		}
		// @@protoc_insertion_point(field_mutable:GameMsg.CommandParams.gameOperation)
		return gameoperation_;
	}
	inline void CommandParams::set_allocated_gameoperation(::GameMsg::GameOperation* gameoperation) {
		::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
		if (message_arena == NULL) {
			delete gameoperation_;
		}
		if (gameoperation) {
			::google::protobuf::Arena* submessage_arena = NULL;
			if (message_arena != submessage_arena) {
				gameoperation = ::google::protobuf::internal::GetOwnedMessage(
					message_arena, gameoperation, submessage_arena);
			}

		}
		else {

		}
		gameoperation_ = gameoperation;
		// @@protoc_insertion_point(field_set_allocated:GameMsg.CommandParams.gameOperation)
	}

	// -------------------------------------------------------------------

	// LoginInfo

	// string username = 1;
	inline void LoginInfo::clear_username() {
		username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
	}
	inline const ::std::string& LoginInfo::username() const {
		// @@protoc_insertion_point(field_get:GameMsg.LoginInfo.username)
		return username_.GetNoArena();
	}
	inline void LoginInfo::set_username(const ::std::string& value) {

		username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
		// @@protoc_insertion_point(field_set:GameMsg.LoginInfo.username)
	}
#if LANG_CXX11
	inline void LoginInfo::set_username(::std::string&& value) {

		username_.SetNoArena(
			&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
		// @@protoc_insertion_point(field_set_rvalue:GameMsg.LoginInfo.username)
	}
#endif
	inline void LoginInfo::set_username(const char* value) {
		GOOGLE_DCHECK(value != NULL);

		username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
		// @@protoc_insertion_point(field_set_char:GameMsg.LoginInfo.username)
	}
	inline void LoginInfo::set_username(const char* value, size_t size) {

		username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
			::std::string(reinterpret_cast<const char*>(value), size));
		// @@protoc_insertion_point(field_set_pointer:GameMsg.LoginInfo.username)
	}
	inline ::std::string* LoginInfo::mutable_username() {

		// @@protoc_insertion_point(field_mutable:GameMsg.LoginInfo.username)
		return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
	}
	inline ::std::string* LoginInfo::release_username() {
		// @@protoc_insertion_point(field_release:GameMsg.LoginInfo.username)

		return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
	}
	inline void LoginInfo::set_allocated_username(::std::string* username) {
		if (username != NULL) {

		}
		else {

		}
		username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
		// @@protoc_insertion_point(field_set_allocated:GameMsg.LoginInfo.username)
	}

	// string password = 2;
	inline void LoginInfo::clear_password() {
		password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
	}
	inline const ::std::string& LoginInfo::password() const {
		// @@protoc_insertion_point(field_get:GameMsg.LoginInfo.password)
		return password_.GetNoArena();
	}
	inline void LoginInfo::set_password(const ::std::string& value) {

		password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
		// @@protoc_insertion_point(field_set:GameMsg.LoginInfo.password)
	}
#if LANG_CXX11
	inline void LoginInfo::set_password(::std::string&& value) {

		password_.SetNoArena(
			&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
		// @@protoc_insertion_point(field_set_rvalue:GameMsg.LoginInfo.password)
	}
#endif
	inline void LoginInfo::set_password(const char* value) {
		GOOGLE_DCHECK(value != NULL);

		password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
		// @@protoc_insertion_point(field_set_char:GameMsg.LoginInfo.password)
	}
	inline void LoginInfo::set_password(const char* value, size_t size) {

		password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
			::std::string(reinterpret_cast<const char*>(value), size));
		// @@protoc_insertion_point(field_set_pointer:GameMsg.LoginInfo.password)
	}
	inline ::std::string* LoginInfo::mutable_password() {

		// @@protoc_insertion_point(field_mutable:GameMsg.LoginInfo.password)
		return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
	}
	inline ::std::string* LoginInfo::release_password() {
		// @@protoc_insertion_point(field_release:GameMsg.LoginInfo.password)

		return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
	}
	inline void LoginInfo::set_allocated_password(::std::string* password) {
		if (password != NULL) {

		}
		else {

		}
		password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
		// @@protoc_insertion_point(field_set_allocated:GameMsg.LoginInfo.password)
	}

	// -------------------------------------------------------------------

	// GameOperation

	// bool moveForward = 1;
	inline void GameOperation::clear_moveforward() {
		moveforward_ = false;
	}
	inline bool GameOperation::moveforward() const {
		// @@protoc_insertion_point(field_get:GameMsg.GameOperation.moveForward)
		return moveforward_;
	}
	inline void GameOperation::set_moveforward(bool value) {

		moveforward_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.GameOperation.moveForward)
	}

	// bool moveBack = 2;
	inline void GameOperation::clear_moveback() {
		moveback_ = false;
	}
	inline bool GameOperation::moveback() const {
		// @@protoc_insertion_point(field_get:GameMsg.GameOperation.moveBack)
		return moveback_;
	}
	inline void GameOperation::set_moveback(bool value) {

		moveback_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.GameOperation.moveBack)
	}

	// bool moveLeft = 3;
	inline void GameOperation::clear_moveleft() {
		moveleft_ = false;
	}
	inline bool GameOperation::moveleft() const {
		// @@protoc_insertion_point(field_get:GameMsg.GameOperation.moveLeft)
		return moveleft_;
	}
	inline void GameOperation::set_moveleft(bool value) {

		moveleft_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.GameOperation.moveLeft)
	}

	// bool moveRight = 4;
	inline void GameOperation::clear_moveright() {
		moveright_ = false;
	}
	inline bool GameOperation::moveright() const {
		// @@protoc_insertion_point(field_get:GameMsg.GameOperation.moveRight)
		return moveright_;
	}
	inline void GameOperation::set_moveright(bool value) {

		moveright_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.GameOperation.moveRight)
	}

	// int32 rotation = 5;
	inline void GameOperation::clear_rotation() {
		rotation_ = 0;
	}
	inline ::google::protobuf::int32 GameOperation::rotation() const {
		// @@protoc_insertion_point(field_get:GameMsg.GameOperation.rotation)
		return rotation_;
	}
	inline void GameOperation::set_rotation(::google::protobuf::int32 value) {

		rotation_ = value;
		// @@protoc_insertion_point(field_set:GameMsg.GameOperation.rotation)
	}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------


	// @@protoc_insertion_point(namespace_scope)

}  // namespace GameMsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Command_2eproto__INCLUDED
